!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){window.onload=()=>{const e=document.getElementById("canvas");e.width=800,e.height=700;const n=e.getContext("webgl2");function r(e,t){const r=n.createShader(e);if(n.shaderSource(r,t),n.compileShader(r),!n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(n.getShaderInfoLog(r));return r}n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT);const o=n.createProgram(),i=r(n.VERTEX_SHADER,t(1).default);n.attachShader(o,i);const c=r(n.FRAGMENT_SHADER,t(2).default);n.attachShader(o,c),n.linkProgram(o),n.useProgram(o);let a=0;const u=100;!function t(){const r=n.getUniformLocation(o,"size");n.uniform2fv(r,[(1+a/u)*e.width,(1+a/u)*e.height]);n.clear(n.COLOR_BUFFER_BIT);n.drawArrays(n.TRIANGLE_FAN,0,4);a=(a+1)%u;requestAnimationFrame(t)}()}},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\nconst vec4 p[] = vec4[](\n\tvec4(1.0, -1.0, 0.0, 1.0),\n\tvec4(1.0, 1.0, 0.0, 1.0),\n\tvec4(-1.0, 1.0, 0.0, 1.0),\n\tvec4(-1.0, -1.0, 0.0, 1.0)\n);\n\nin float a;\n\nvoid main() {\n  gl_Position = p[gl_VertexID];\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\nprecision mediump float;\nout vec4 color;\nuniform vec2 size;\nconst int level = 8;\n\nvoid main() {\n  color = vec4(1.0, 1.0, 1.0, 1.0);\n  vec2 p = gl_FragCoord.xy / size;\n  if (p.x + p.y / 2.0 > 1.0 ||\n      p.x - p.y / 2.0 < 0.0 ||\n      p.y < 0.0) {\n    discard;\n    return;\n  }\n  for (int i = 0; i < level; i++) {\n    p *= 2.0;\n    if (floor(mod(p.x + p.y / 2.0, 2.0)) == 1.0 &&\n        floor(mod(p.x - p.y / 2.0, 2.0)) == 0.0 &&\n        floor(mod(p.y, 2.0)) == 0.0) {\n      discard;\n      return;\n    }\n  }\n}"}]);